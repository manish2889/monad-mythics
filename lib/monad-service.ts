/**
 * Real Monad Blockchain Integration Service
 *
 * This service provides real blockchain functionality using the deployed MonadStoryNFT contract.
 */

import { MonadStoryNFTWriter, MonadStoryNFTReader, MONAD_STORY_NFT_ADDRESS } from './contracts/monadStoryNFT';

// Story metadata interface for NFT minting
export interface StoryMetadata {
  title: string;
  content: string;
  genre: string;
  author: string;
  timestamp: number;
  aiModel?: string;
  tags?: string[];
  description?: string;
  excerpt?: string;
  authorAddress?: string;
  coverImage?: string;
  createdAt?: string;
  aiPrompt?: string;
}

// Minted NFT result interface
export interface MintedNFT {
  tokenId: string;
  contractAddress?: string;
  transactionHash: string;
  metadata: StoryMetadata;
  owner?: string;
  tokenURI?: string;
}

// Helper function to create IPFS metadata
async function createMetadataURI(metadata: StoryMetadata): Promise<string> {
  // For now, return a placeholder - in production, you'd upload to IPFS
  // This should be replaced with actual IPFS upload logic
  const metadataJson = {
    name: metadata.title,
    description: metadata.description || metadata.excerpt || `A story by ${metadata.author}`,
    image: metadata.coverImage || 'https://via.placeholder.com/400x400?text=Story+NFT',
    attributes: [
      { trait_type: 'Genre', value: metadata.genre },
      { trait_type: 'Author', value: metadata.author },
      { trait_type: 'AI Model', value: metadata.aiModel || 'Unknown' },
      { trait_type: 'Created At', value: new Date(metadata.timestamp).toISOString() },
    ],
    external_url: process.env.NEXT_PUBLIC_URL || 'https://groqtales.com',
    story_content: metadata.content,
    ai_prompt: metadata.aiPrompt,
  };
  
  // Return a placeholder URI - replace with actual IPFS upload
  return `data:application/json;base64,${Buffer.from(JSON.stringify(metadataJson)).toString('base64')}`;
}

// Helper function to create story content hash
async function createStoryHash(content: string): Promise<string> {
  // For now, return a placeholder - in production, you'd upload content to IPFS
  // This should be replaced with actual IPFS upload logic
  return `data:text/plain;base64,${Buffer.from(content).toString('base64')}`;
}

// Function to generate and mint AI story
export async function generateAndMintAIStory(
  prompt: string,
  ownerAddress: string,
  title: string,
  genre: string,
  apiKey?: string
): Promise<MintedNFT> {
  console.log('Real generateAndMintAIStory called - using actual contract');
  
  try {
    // This function should integrate with your AI story generation
    // For now, we'll create a placeholder story
    const storyContent = `Generated story based on prompt: "${prompt}"\n\nThis is a placeholder story that would be generated by your AI service.`;
    
    const metadata: StoryMetadata = {
      title,
      content: storyContent,
      genre,
      author: 'AI Assistant',
      timestamp: Date.now(),
      aiModel: 'Groq',
      authorAddress: ownerAddress,
      aiPrompt: prompt,
      description: `An AI-generated story in the ${genre} genre`,
    };

    return await mintStoryNFT(metadata, ownerAddress);
  } catch (error) {
    console.error('Error in generateAndMintAIStory:', error);
    throw error;
  }
}

// Function to mint story NFT
export async function mintStoryNFT(
  metadata: StoryMetadata,
  walletAddress: string
): Promise<MintedNFT> {
  console.log('Real mintStoryNFT called - using actual contract');
  
  try {
    // Create IPFS hashes (placeholder implementation)
    const storyHash = await createStoryHash(metadata.content);
    const metadataURI = await createMetadataURI(metadata);
    
    // Count images in content (simple implementation)
    const imageCount = (metadata.content.match(/!\[.*?\]\(.*?\)/g) || []).length;
    
    console.log('Minting with:', {
      storyHash,
      metadataURI,
      imageCount,
      contractAddress: MONAD_STORY_NFT_ADDRESS,
    });

    // Mint using the real contract
    const result = await MonadStoryNFTWriter.mintStory(
      storyHash,
      metadataURI,
      imageCount
    );

    return {
      tokenId: result.tokenId,
      contractAddress: MONAD_STORY_NFT_ADDRESS,
      transactionHash: result.transactionHash,
      metadata,
      owner: walletAddress,
      tokenURI: metadataURI,
    };
  } catch (error) {
    console.error('Error minting story NFT:', error);
    throw error;
  }
}

// Function to get story NFT details
export async function getStoryNFT(tokenId: string): Promise<MintedNFT | null> {
  console.log('Real getStoryNFT called - using actual contract');
  
  try {
    const tokenIdNum = parseInt(tokenId);
    
    // Get story details from contract
    const storyDetails = await MonadStoryNFTReader.getStoryDetails(tokenIdNum);
    const owner = await MonadStoryNFTReader.getOwnerOf(tokenIdNum);
    const tokenURI = await MonadStoryNFTReader.getTokenURI(tokenIdNum);
    
    // Parse metadata from URI (this is a simplified version)
    // In production, you'd fetch from IPFS
    let metadata: StoryMetadata = {
      title: `Story #${tokenId}`,
      content: 'Story content would be loaded from IPFS',
      genre: 'Unknown',
      author: 'Unknown',
      timestamp: Date.now(),
    };

    return {
      tokenId,
      contractAddress: MONAD_STORY_NFT_ADDRESS,
      transactionHash: '', // Not available for existing NFTs
      metadata,
      owner,
      tokenURI,
    };
  } catch (error) {
    console.error('Error getting story NFT:', error);
    return null;
  }
}

// Function to transfer story NFT
export async function transferStoryNFT(
  tokenId: string,
  fromAddress: string,
  toAddress: string
): Promise<string> {
  console.log('Real transferStoryNFT called - using actual contract');
  
  try {
    const tokenIdNum = parseInt(tokenId);
    const txHash = await MonadStoryNFTWriter.transferFrom(fromAddress, toAddress, tokenIdNum);
    return txHash;
  } catch (error) {
    console.error('Error transferring story NFT:', error);
    throw error;
  }
}

// Function to get user's story NFTs
export async function getStoryNFTs(walletAddress: string): Promise<MintedNFT[]> {
  console.log('Real getStoryNFTs called - using actual contract');
  
  try {
    // Get user's NFT balance
    const balance = await MonadStoryNFTReader.getBalanceOf(walletAddress);
    
    // For now, return empty array since we need to implement token enumeration
    // In production, you'd use event logs or a subgraph to get token IDs
    console.log(`User ${walletAddress} owns ${balance} Story NFTs`);
    
    return [];
  } catch (error) {
    console.error('Error getting story NFTs:', error);
    return [];
  }
}
